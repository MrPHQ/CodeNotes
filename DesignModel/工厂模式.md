# 目录

* [工厂模式](#工厂模式)
* [工厂方法模式](#工厂方法模式)
* [抽象工厂模式](#抽象工厂模式)


## 工厂模式

    除了使用`new`操作法之外，还有更多制造对象的方法. 

    实例化不应该总是公开地进行

    初始化经常造成'耦合'问题

    了解工厂模式如何从复杂的依赖中帮你脱困

不应该针对实现编程，但是当我每次使用`new`时，不正是在针对实现编程吗?
****
当看到`new`,就会想到`具体`(实例化一个具体类)
```c++
Duck duck = new MallardDuck();
```
使用接口让代码有弹性 `Duck duck` , 但还是得建立具体类的实例 `new MallardDuck`

当有一群相关的具体类时,通常会写出这样的代码
```c++
Duck duck;
if(picnic){
  duck = new MallardDuck();
}else if(hunting){
  duck = new DecoyDuck();
}else if(inBathTub){
  duck = new RubberDuck();
}
```
有一大堆鸭子类，但是必须等到运行时，才知道该实例化哪一个  
当看到这样的代码，一旦有变化或扩展，就必须重新打开这段代码进行检查和修改。通过这样的修改过的代码将造成部分系统更难维护和更新，而且容易犯错。

如何将实例化具体类的代码从应用中抽离，或封装起来，使他们不会干扰应用的其他部分
****
```c++
Pizza orderPizza(){
  Pizza pizza = new Pizza();
  pizza.prepare();
  pizza.bake();
  pizza.cut();
  pizza.box();
  return pizza;
}
```
为了让系统有弹性，我们希望`Pizza`这是一个抽象类或接口，但如果这样，这些类或接口就无法直接实例化

需要更多披萨类型
```c++
Pizza orderPizza(type){//传入类型
  Pizza pizza;
  if(type == 'a'){
    pizza = new CheesePizza();
  }else if(type == 'b'){
    pizza = new GreekPizza();
  }else if(type == 'c'){
    pizza = new PepperoniPizza();
  }
  pizza.prepare();
  pizza.bake();
  pizza.cut();
  pizza.box();
  return pizza;
}
```
类型的增加或减少就会反复的修改这里的代码
```c++
Pizza orderPizza(type){//传入类型
  Pizza pizza;
  if(type == 'a'){
    pizza = new CheesePizza();
  //}else if(type == 'b'){//删除
  //  pizza = new GreekPizza();
  }else if(type == 'c'){
    pizza = new PepperoniPizza();
  }else if(type == 'd'){//新增
  }else if(type == 'e'){
  }
  pizza.prepare();
  pizza.bake();
  pizza.cut();
  pizza.box();
  return pizza;
}


## 工厂方法模式


## 抽象工厂模式
