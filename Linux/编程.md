# 目录
* [系统](#系统)  
    * [守护进程](#守护进程)  
* [功能](#功能)  
    * [获取模块路径](#获取模块路径)  
    * [创建进程](#创建进程)  
    * [IPC](#IPC)  
    	* [本地socket](#本地socket)  
	* [共享内存](#共享内存)  
    
# 系统
## 守护进程
[转载](http://cdeveloper.cn/posts/daemon "http://cdeveloper.cn/posts/daemon")

**什么是守护进程**

        守护进程可以简单的理解为后台的服务进程，很多上层的服务器都是以守护进程为基础开发的。
        例如 Linux 上运行的 Apache 服务器，Android 系统的 Service 服务，它们的底层都由 Linux 的守护进程提供服务。
**编写守护进程的 6 个步骤**

        1. 重新设置 umask(0)
        2. 执行 fork 并脱离父进程
        3. 重启 session 会话
        4. 改变当前工作目录
        5. 关闭文件描述符
        6. 固定文件描述符 0, 1, 2 到 /dev/null
**示例**
```c++
void daemon_init(void) {
 	// 1. 重新设置 umask
	umask(0); 
	
	// 2. 调用 fork 并脱离父进程
	pid_t pid = fork()  ; 
	
	if(pid < 0)
		exit(1); 
	else if(pid > 0)
		exit(0);

	// 3. 重启 session 会话
	setsid();

	// 4. 改变工作目录
	chdir("/"); 

	// 5. 得到并关闭文件描述符
	struct rlimit rl;
	getrlimit(RLIMIT_NOFILE, &rl);
	if (rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(int i = 0; i < rl.rlim_max; i++)	
		close(i); 
	
	// 6. 不接受标准输入，输入，错误
	int fd0 = open("/dev/null", O_RDWR);
	int fd1 = dup(0);
	int fd2 = dup(0);	 
}
```
**让守护进程开机自启动**

每个系统启动级别的守护进程分别在 /etc/rcN.d 下，比如我的图形界面的启动级别是 5，那么在这个启动级别下自动运行和禁止启动守护进程都在 /etc/rc5.d 下.这里我的 ubuntu 系统的守护进程目录是 /etc/rcN.d

知道了守护进程的位置，现在就可以把 printlg 放在 /etc/rc5.d/ 下，并且还要改名称，因为系统需要根据指定的名称来使用 for 循环来启动或者关闭每个程序，命名规则如下：
S[num][name]：启动守护进程 name，例如：S01printlg
K[num][name]：禁止启动守护进程 name，例如：K01printlg
```
ln -s /mnt/my_proj/linux/daemon/printlg ./S01printlg
```

# 功能
## 获取模块路径
* **获取dlopen加载的动态库路径, 编译时的连接选项 -ldl**
```cpp
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

void identify_function_ptr( void *func)  {   
  Dl_info info;  
  int rc;      

  rc = dladdr(func, &info);   
  if (!rc)  {    
      printf("Problem retrieving program information for %x:  %s\n", func, dlerror()); 
  }  
  printf("Address located in function %s within the program %s\n", info.dli_fname, info.dli_sname);  
}
```

* **利用proc获取绝对路径**
```cpp
const char* CMysqlConn::GetCurrentPathUnix()
{
    static char buf[512] = {0}; 
    int count;  

    if(strlen(buf) > 0)
        return buf;
    buf[0] == '\0';
    count = readlink( "/proc/self/exe", buf, 512 );  
    if ( count > 0 && count < 512 )  
    {   
    	buf[count] = '\0';  
    }   
    return buf;
}
```
注意:这个路径包括可执行文件名，只获取路径需要去掉最后的可执行文件名

* **getcwd**
函数返回的是当时的执行路径
```cpp
char buffer[256];
buffer[0] = '\0';
getcwd(buffer, sizeof(buffer));
printf("current path x:%s \n", buffer);
```
[回到顶部](#目录) 

## 创建进程
* **fork**  
函数`fork()`用来创建一个新的进程，该进程几乎是当前进程的一个完全拷贝  
>fork在英文中是"分叉"的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork，就产生了另一个进程，于是进程就"分叉"了，所以这个名字取得很形象
```cpp
void main()
{
    int i;
    if ( fork() == 0 ) 
    {
       /* 子进程程序 */
       for ( i = 1; i <1000; i ++ ) 
          printf("This is child process\n");
    }
    else 
    {
       /* 父进程程序*/
       for ( i = 1; i <1000; i ++ ) 
       printf("This is process process\n");
    }
}
```
* **exec函数族**  
一个进程一旦调用exec类函数，它本身就"死亡"了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。  
在 Linux中，它们分别是：execl，execlp，execle，execv，execve和execvp  
如果我的程序想启动另一程序的执行但自己仍想继续运行的话，怎么办呢？那就是结合fork与exec的使用,如下:
```cpp
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

char command[256];
void main()
{
   int rtn; /*子进程的返回数值*/
   while(1) {
       /* 从终端读取要执行的命令 */
       printf( ">" );
       fgets( command, 256, stdin );
       command[strlen(command)-1] = 0;
       if ( fork() == 0 ) {/* 子进程执行此命令 */
          execlp( command, NULL );
          /* 如果exec函数返回，表明没有正常执行命令，打印错误信息*/
          perror( command );
          exit( errno );
       }
       else {/* 父进程， 等待子进程结束，并打印子进程的返回值 */
          wait ( &rtn );
          printf( " child process return %d\n", rtn );
       }
   }
}
```
```cpp
#include <unistd.h>
extern char **environ;
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```

其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。  
exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。  

函数名与参数的关系：  
细看一下，这6个函数都是以`exec`开头（表示属于`exec`函数组），前3个函数接着字母l的，后3个接着字母`v`的，我的理解是`l`表示list（列举参数），`v`表示vector（参数向量表）。它们的区别在于，`execv`开头的函数是以`"char *argv[]"(vector)`形式传递命令行参数，而`execl`开头的函数采用了罗列(list)的方式，把参数一个一个列出来，然后以一个NULL表示结束。这里的NULL的作用和argv数组里的NULL作用是一样的。  
字母`p`是指在环境变量PATH的目录里去查找要执行的可执行文件。2个以p结尾的函数execlp和execvp，看起来，和execl与execv的差别很小，事实也如此，它们的区别从第一个参数名可以看出：除 execlp和execvp之外的4个函数都要求，它们的第1个参数path必须是一个完整的路径，如"/bin/ls"；而execlp和execvp 的第1个参数file可以仅仅只是一个文件名，如"ls"，这两个函数可以自动到环境变量PATH指定的目录里去查找。  
字母`e`是指给可执行文件指定环境变量。在全部6个函数中，只有`execle`和`execve`使用了`char *envp[]`传递环境变量，其它的4个函数都没有这个参数，这并不意味着它们不传递环境变量，这4个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而`execle`和`execve`用指定的环境变量去替代默认的那些。  

**返回值**  
与一般情况不同，`exec`函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只有进程ID等一些表面上的信息仍保持原样。调用失败时，会设置`errno`并返回-1，然后从原程序的调用点接着往下执行。  

[回到顶部](#目录) 

## IPC
### 本地socket
[本地socket unix domain socket](http://blog.csdn.net/bingqingsuimeng/article/details/8470029)

### 共享内存
* 创建
```c++
#include <sys/ipc.h>
#include <sys/shm.h>
/*
 * key：SHM 标识
 * size：SHM 大小
 * shmflg：创建或得到的属性，例如 IPC_CREAT
 * return：成功返回 shmid，失败返回 -1，并设置 erron
 */
int shmget(key_t key, size_t size, int shmflg);
```
* 映射
`shmat`将由 `shmget` 返回的 `shmid` 标识的 SHM 映射到进程的地址空间：
```c++
#include <sys/types.h>
#include <sys/shm.h>
/*
 * shmid：SHM ID
 * shmaddr：SHM 内存地址
 * shmflg：SHM 权限
 * return：成功返回 SHM 的地址，失败返回 (void *) -1，并设置 erron
 */
void *shmat(int shmid, const void *shmaddr, int shmflg);
```
其中 shmaddr 参数主要有 2 种情况：  
shmaddr = NULL：系统选择一块合适的内存地址作为映射的起始地址  
shmaddr != NULL：用户自己地址，但是该地址需要符合一定的条件，详情参考 man shmat  
* 关闭映
shmdt 解除当前进程映射的 SHM  
```c++
#include <sys/types.h>
#include <sys/shm.h>
/*
 * shmaddr：已经映射的 SHM 地址
 * return：成功返回 0，失败返回 -1，并设置 erron
 */
int shmdt(const void *shmaddr);
```
* 使用常见陷阱与分析
[转载](http://os.51cto.com/art/201311/418977_all.htm)
1. 超过共享内存的大小限制？
	在一个linux服务器上，共享内存的总体大小是有限制的，这个大小通过SHMMAX参数来定义（以字节为单位），您可以通过执行以下命令来确定 SHMMAX 的值： 
	>cat /proc/sys/kernel/shmmax 
2. 多次进行shmat会出现什么问题？  
	一个进程是可以对同一个共享内存多次 shmat进行挂载的，物理内存是指向同一块，如果shmaddr为NULL，则每次返回的线性地址空间都不同。而且指向这块共享内存的引用计数会增加。也就是进程多块线性空间会指向同一块物理地址。这样，如果之前挂载过这块共享内存的进程的线性地址没有被shmdt掉，即申请的线性地址都没有释放，就会一直消耗进程的虚拟内存空间，很有可能会最后导致进程线性空间被使用完而导致下次shmat或者其他操作失败。  
	**解决方法：**  
	可以通过判断需要申请的共享内存指针是否为空来标识是否是第一次挂载共享内存，若是则使用进行挂载，若不是则退出。
	```c++
	void* ptr = NULL; 
	....
	if (NULL != ptr) 
		return; 
	ptr = shmat(shmid,ptr,0666); 
	```
3. shmget创建共享内存，当key相同时，什么情况下会出错？  
	shmget() 用来创建一个共享内存区，或者访问一个已存在的共享内存区,该函数定义在头文件 linux/shm.h中，原型如下：  
	>int shmget(key_t key, size_t size, int shmflg); 

	参数 key是由 ftok() 得到的键值;  
	参数 size 是以字节为单位指定内存的大小;  
	参数 shmflg 是操作标志位，它的一些宏定义如下:  
	`IPC_CREATE` : 调用 `shmget` 时，系统将此值与其他共享内存区的 `key` 进行比较，如果存在相同的 `key` ，说明共享内存区已存在，此时返回该共享内存区的标识符，否则新建一个共享内存区并返回其标识符.  
	`IPC_EXCL` : 该宏必须和 `IPC_CREATE` 一起使用，否则没意义。当 shmflg 取 `IPC_CREATE | IPC_EXCL` 时，表示如果发现内存区已经存在则返回` -1`，错误代码为 `EEXIST`.  
	注意，当创建一个新的共享内存区时，size 的值必须大于 0 ；如果是访问一个已经存在的内存共享区，则置 size 为 0.  
4. 如果创建进程和挂接进程key相同，而对应的size大小不同，是否会shmget失败？  
	已经创建的共享内存的大小是可以调整的，但是已经创建的共享内存的大小只能调小，不能调大.  
	当多个进程都能创建共享内存的时候，如果key出现相同的情况，并且一个进程需要创建的共享内存的大小要比另外一个进程要创建的共享内存小，共享内存大的进程先创建共享内存，共享内存小的进程后创建共享内存，小共享内存的进程就会获取到大的共享内存进程的共享内存， 并修改其共享内存的大小和内容（留意下面的评论补充），从而可能导致大的共享内存进程崩溃.    
	**解决方法：**  
	方法一：  
	在所有的共享内存创建的时候，使用排他性创建，即使用IPC_EXCL标记:  
	```Shmget(key, size,IPC_CREATE|IPC_EXCL); ```  
	在共享内存挂接的时候，先使用排他性创建判断共享内存是否已经创建，如果还没创建则进行出错处理，若已经创建，则挂接:    
	```cpp
	Shmid = Shmget(key, size,IPC_CREATE|IPC_EXCL); 
	If (-1 != shmid) 
	{ 
	Printf("error"); 
	} 
	Shmid = Shmget(key, size,IPC_CREATE); 
	```
5. ftok是否一定会产生唯一的key值？  
	系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过ftok函数得到。  
	ftok原型如下：  
	```key_t ftok( char * pathname, int proj_id) ```  
	pathname就时你指定的文件名，proj_id是子序号。
6. 共享内存删除的陷阱？  

[回到顶部](#目录) 
