# 目录

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。

# 函数模版
模板函数定义的一般形式如下所示：
```cpp
template <class type> ret-type func-name(parameter list)
{
   // 函数的主体
}
```

```cpp
template <typename T>
inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
} 
```

# 类模板
```cpp
template <class type> class class-name {
.
.
.
}
```
在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。   
定义了类 Stack<>，并实现了泛型方法来对元素进行入栈出栈操作：
```cpp
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>
 
using namespace std;
 
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
 
template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 
 
template <class T>
void Stack<T>::pop () 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
    // 删除最后一个元素
    elems.pop_back();         
} 
 
template <class T>
T Stack<T>::top () const 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
    // 返回最后一个元素的副本 
    return elems.back();      
} 
```

## typename和class的区别
在 C++ Template 中很多地方都用到了 `typename` 与 `class` 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?  
相信学习 C++ 的人对 class 这个关键字都非常明白，`class` 用于定义类，在模板引入` c++` 后，最初定义模板的方法为：  
`template<class T>......`  
这里 `class` 关键字表明`T`是一个类型，后来为了避免 `class` 在这两个地方的使用可能给人带来混淆，所以引入了 `typename` 这个关键字，它的作用同
`class` 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：  
`template<typename T>......`  
在模板定义语法中关键字 class 与 typename 的作用完全一样。  
`typename` 难道仅仅在模板定义中起作用吗？其实不是这样，`typename` 另外一个作用为：使用`嵌套依赖类型(nested depended name)`，如下所示：  
```cpp
class MyArray 
{ 
    public：
    typedef int LengthType;
.....
}

template<class T>
void MyMethod( T myarr ) 
{ 
    typedef typename T::LengthType LengthType; 
    LengthType length = myarr.GetLength; 
}
```
这个时候 typename 的作用就是告诉 c++ 编译器，`typename` 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有
typename，编译器没有任何办法知道 `T::LengthType` 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。
