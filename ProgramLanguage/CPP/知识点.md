# 目录


## 为什么没有虚析构函数的类继承是危险的
如果一个类的析构函数是非虚的，那么就意味着它不会作为基类来使用（这种类就是我们所熟知的“实体类”）。std::string，std::complex，以及std::vector都是实体类。为什么不推荐继承这些类呢？当你使用公共继承时，你就会在基类与派生类之间创建一种is-a的关系。因此，基类的指针和引用实际上可以指向一个派生的对象。由于析构函数不是虚的，所以当您删除这样一个对象时，C++将不会调用整个析构链
```c++
class A
{
public:
  ~A() // non virtual
};
class B: public A /* 不好; A 没有虚析构函数*/
{
public:
  ~B()
};
int main()
{
 A * p = new B; /*貌似没什么问题*/
 delete p; /*问题出现, B的析构未被调用*/
}
```
## 如何优雅的处理分支判断
[转载](http://ju.outofmemory.cn/entry/56050)
```c++
#include <memory>

typedef std::pair<std::function<bool(int)>,std::function<void()> > ifdo_t;
typedef std::shared_ptr<ifdo_t> ifdo_ptr;
typedef std::vector<ifdo_ptr> ifdo_container_t;

template<class F1, class F2>
void add_case(F1 &&p, F2 && f)
{
	allcases.push_back(std::make_shared<ifdo_t>(p, f));
}
ifdo_container_t allcases;

void do_1_100(const char* p) { std::cout << p << std::endl; }
void do_100_200(const char* p) { std::cout << p << std::endl; }
void do_200_300(const char* p) { std::cout << p << std::endl; }
void do_400(const char* p) { std::cout << p << std::endl; }

int main()
{
	int number = 600;
	add_case([](int num) -> bool {return num >1 && num <= 100; },
		[&](){do_1_100("do_1_100"); });
	add_case([](int num) -> bool {return num >100 && num <= 20; },
		[&](){do_100_200("do_100_200"); });
	add_case([](int num) -> bool {return num >300 && num <= 400; },
		[&](){do_200_300("do_200_300"); });
	add_case([](int num) -> bool {return num >400; },
		[&](){do_400("do_400"); });

	for (ifdo_container_t::iterator it = allcases.begin(); it != allcases.end(); it++)
	{
		if ((*it)->first(number))
			(*it)->second();
	}
	std::cin.ignore();
    return 0;
}
```
